<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Regular  Expressions</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script type="text/javascript"
          src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js">
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github.min.css">
    <link href="../../assets/styles/article.css" rel="stylesheet" type="text/css" /> 
</head>

<body class=umt-slides>

    <nav id="course-nav">
      <ul>
      </ul>
    </nav>
    
    <div class="umt-content">
      <div><section data-level="h1"><h1>Regular  Expressions</h1><section data-level="h2"><h2>Overview</h2><ul><li><p>Basic regex's.
</p></li><li><p><code>String</code> methods.
</p></li><li><p><code>RegExp</code> methods.
</p></li><li><p>Crawler 
</p></li></ul></section><section data-level="h2"><h2>Regular Expressions Introduction</h2><ul><li><p>Regex's provide special syntax for string matching.
</p></li><li><p>Allows matching, sub-string extraction and substitution.
</p></li><li><p>Initially popularized by early Unix tools.
</p></li><li><p>Indispensable tool in every programmer's toolbox.
</p></li></ul></section><section data-level="h2"><h2>Basic Regex Syntax</h2><p>A regular expression literal can be written within <code>/</code> delimiters.
</p><dl><dt> <code>/hello/</code> </dt><dd><p>    Matches the string <code>&quot;hello&quot;</code>.
</p></dd><dt> <code>/hello|world/</code> </dt><dd><p>    Matches either the string <code>&quot;hello&quot;</code> or the string <code>&quot;world&quot;</code>.
    <code>|</code> is the <strong>alternation operator</strong>.
</p></dd><dt> <code>/[hH]ello/</code> </dt><dd><p>    Matches either the string <code>&quot;hello&quot;</code> or the string <code>&quot;Hello&quot;</code>.
    <code>[hH]</code> is a character class equivalent to <code>/(h|H)/</code>.
</p></dd><dt> <code>/[0-9]/</code> </dt><dd><p>    Matches a digit.  <code>[0-9]</code> is a <strong>range character class</strong>.
</p></dd><dt> <code>/[^0-9]/</code> </dt><dd><p>   Matches a non-digit. <code>[^0-9]</code> is a <strong>negated character class</strong>.
</p></dd><dt> <code>/worlds?/</code> </dt><dd><p>    Matches either the string <code>&quot;worlds&quot;</code> or the string <code>&quot;world&quot;</code>.
    <code>?</code> is a suffix operator indicating that the preceeding
    sub-regex is <strong>optional</strong>.
</p></dd></dl></section><section data-level="h2"><h2>Basic Regex Syntax: Continued</h2><dl><dt> <code>/[0-9]+/</code> </dt><dd><p>    Matches one-or-more digits.  <code>+</code> is a suffix operator indicating
    <strong>one-or-more</strong> matches of the preceeding regex.
</p></dd><dt> <code>/[a-zA-Z]*/</code> </dt><dd><p>    Matches zero-or-more lowercase or uppercase alphabetic characters.
    <code>*</code> is a suffix operator indicating <strong>zero-or-more</strong> matches of the
    preceeding regex.
</p></dd></dl><ul><li><p>So the basic regular expression operators in order of decreasing
    precedence are:
</p><dl><dt> Quantifiers optional <code>?</code>, one-or-more <code>+</code>, zero-or-more <code>*</code></dt><dd><p>       Indicated by unary suffix operators.
</p></dd><dt>Concatenation</dt><dd><p>       Indicated by juxtaposition.
</p></dd><dt>Alternation</dt><dd><p>       Indicated by infix binary operator <code>|</code>.
</p></dd></dl></li><li><p>Use parentheses <code>(</code> <code>)</code> to override default precedence.
</p></li></ul></section><section data-level="h2"><h2>Escaping Special Characters</h2><ul><li><p>Characters like <code>+</code>, <code>*</code> <code>|</code>, <code>?</code>, <code>(</code>, <code>)</code> are part of the
    regular expression notation and are referred to as
    special characters or <strong>meta-characters</strong>.
</p></li><li><p>Special characters can be escaped by preceeding them with a <code>\</code>
    character.  For example, <code>/hello\*/</code> is a regex matching the
    string <code>&quot;hello*&quot;</code>.
</p></li><li><p>The <code>\</code> character can itself be escaped using a preceeding <code>\</code>.
    Hence <code>/hello\\/</code> is a regex matching the string <code>&quot;hello&quot;</code>
    followed by a <code>\</code> character.
</p></li><li><p>Within a character class the usual meta-characters loose their
    meaning and do not need to be escaped; the only characters which
    are special are the range operator <code>-</code> (though not at the start),
    and the negated character class operator <code>^</code> (only at the start) and
    <code>\</code> for escaping.
</p></li></ul></section><section data-level="h2"><h2>More Regex Examples</h2><dl><dt> <code>/[1-9][0-9]*|0/</code> </dt><dd><p>   Matches an integer with no non-significant leading zeros.
</p></dd><dt> <code>/[-+]?[0-9]+/</code> </dt><dd><p>   Matches an integer with an optional sign (no restriction
   on leading zeros).
</p></dd><dt> <code>/[0-9]+[lL]?/</code> </dt><dd><p>   Matches an integer with an optional suffix of <code>l</code> of <code>L</code> (no restriction
   on leading zeros).
</p></dd><dt> <code>/[a-zA-Z_][a-zA-Z0-9_]*/</code> </dt><dd><p>   Matches the definition of an <em>identifier</em> in many programming languages.
   An identifier consists of one or more alphanumeric characters or underscores
   with the restriction that the first character cannot be a digit.
</p></dd></dl></section><section data-level="h2"><h2>String <code>search()</code> Method</h2><p> Invoking <code>search(</code>  <code>regex</code>  <code>)</code> on a string will return the index
 of the start of the first match of <em>regex</em> in the string; -1 if not found.
</p><pre class="hljs language-javascript">> &quot;abcd123&quot;.search(/[a-z]+[0-9]+/)
0
> &quot;+-abcd123&quot;.search(/[a-z]+[0-9]+/)
2
> &quot;+-abcd&quot;.search(/[a-z]+[0-9]+/)
-1
</pre></section><section data-level="h2"><h2>String <code>match()</code> Method</h2><p>Invoking <code>match(</code><em>regex</em><code>)</code> on a string results in an &quot;array<code></code>&quot;:
</p><ul><li><p>Element 0 contains the entire match.
</p></li><li><p>Elements \(\;n\) for \(\;n > 0\) contains the substring matched by
    the \(\;n\)'th <strong>capturing parentheses</strong> group.
</p></li><li><p>An <code>index</code> property contains the index of the
    start of the match in the input string.
</p></li><li><p>An <code>input</code> property contains the input string.
</p></li></ul></section><section data-level="h2"><h2>String <code>match()</code> Examples</h2><pre class="hljs language-javascript">> &quot;abc123&quot;.match(/[a-z]+[0-9]+/)
[ 'abc123', index: 0, input: 'abc123' ]
> &quot;abc123&quot;.match(/([a-z]+)([0-9]+)/)
[ 'abc123', 'abc', '123', index: 0, input: 'abc123' ]
> &quot;+-/abc123&quot;.match(/([a-z]+)([0-9]+)/)
[ 'abc123', 'abc', '123', index: 3, input: '+-/abc123' ]
> &quot;+-abc123&quot;.match(/(([\-\+])[a-z]+)([0-9]+)/)
[ '-abc123', '-abc', '-', '123', index: 1, input: '+-abc123' ]
> [, a, b] = //destructuring
   'abc3-123'.match(/([a-z0-9]+)\-([0-9]+)/) 
[ 'abc3-123', 'abc3', '123', index: 0,
  input: 'abc3-123' ]
> [a, b]
[ 'abc3', '123' ]
>
</pre></section><section data-level="h2"><h2>String <code>split()</code> Method</h2><p>Can split a string on a string or regex:
</p><pre class="hljs language-javascript">// split on string
> 'axxcxxd'.split('xx')
[ 'a', 'c', 'd' ]

//split on empty string to split into chars
> 'abcd'.split('')  
[ 'a', 'b', 'c', 'd' ]

// split on space using regex
> &quot;ab, x12, de , f&quot;.split(/ +/)
[ 'ab,', 'x12,', 'de', ',', 'f' ]

// split on , optionally surrounded by space
> &quot;ab, x12, de , f&quot;.split(/ *, */)
[ 'ab', 'x12', 'de', 'f' ]
</pre></section><section data-level="h2"><h2>More Regex Syntax</h2><p><code>[a-z]</code> not portable as it depends on the character codes for
lowercase characters being adjacent in the underlying character set.
True in ASCII, but for example, in EBCDIC alphabetic character codes
are not contiguous.
</p><dl><dt> <strong>Digit Char</strong> <code>/\d/</code> </dt><dd><p>    A regular expression which matches any digit.
</p></dd><dt> <strong>Non-Digit Char</strong> <code>/\D/</code> </dt><dd><p>    A regular expression which matches any non-digit.
</p></dd><dt> <strong>Word Char</strong> <code>/\w/</code> </dt><dd><p>    A regular expression which matches any word-char (alphanumeric or
    <code>_</code>).
</p></dd><dt> <strong>Non-Word Char</strong> <code>/\W/</code> </dt><dd><p>    A regular expression which matches any non-word-char.
</p></dd><dt> <strong>Space Char</strong> <code>/\s/</code> </dt><dd><p>    A regular expression which matches any whitespace character
    (blank, tab, newline etc.).
</p></dd><dt> <strong>Non-Space Char</strong> <code>/\S/</code> </dt><dd><p>    A regular expression which matches any non-whitespace character.
</p></dd><dt> <strong>Any char other than newline</strong> <code>/./</code> </dt><dd><p>    Matches any character other than newline.
</p></dd></dl></section><section data-level="h2"><h2>Fixed Count or Range Count Quantifiers</h2><dl><dt> <code>/\d{5}/</code> </dt><dd><p>    Matches exactly 5 digits.  Suffix <code>{</code>  <code>n</code>  <code>}</code> means match
    exactly <em>n</em> occurrences of preceeding regex.
</p></dd><dt> <code>/\d{5,}/</code> </dt><dd><p>    Matches at least 5 digits.  Suffix <code>{</code>  <code>n</code>  <code>,}</code> means match
    at least <em>n</em> occurrences of preceeding regex.
</p></dd><dt> <code>/\d{2,5}/</code> </dt><dd><p>    Matches 2 - 5 digits.  Suffix <code>{</code>  <code>n</code>  <code>,</code>  <code>m</code>  <code>}</code>
    means match <em>n</em> through <em>m</em> occurrences of preceeding regex.
</p></dd><dt> <code>/[a-zA-Z_]\w{0,7}/</code> </dt><dd><p>    Matches an identifer containing upto 8 characters.
</p></dd></dl></section><section data-level="h2"><h2>Context Regex Syntax</h2><p>Does not actually match anything, just provides a <strong>context</strong> for
other regex's to match.  Often known as  <strong>anchor</strong>'s
</p><dl><dt> <code>/^\d/</code> </dt><dd><p>    Matches a digit but only at the start of the input string.
    Can be set to match at start of a line if <code>m</code> flag set.
</p></dd><dt> <code>/\d$/</code> </dt><dd><p>    Matches a digit but only at the end of the input string.
    Can be set to match at end of a line if <code>m</code> flag set.
</p></dd><dt> <code>/\bm/</code> </dt><dd><p>    Matches a <code>m</code> but only on a word boundary.  Hence it will
    match only the first <code>m</code> in the word <code>&quot;mommy&quot;</code>.
</p></dd><dt> <code>/\Bm/</code> </dt><dd><p>    Matches a <code>m</code> which is <strong>not</strong> on a word boundary.  Hence it will
    match only the internal <code>m</code>'s in the word <code>&quot;mommy&quot;</code>.
</p></dd></dl></section><section data-level="h2"><h2>More on Capturing Groups</h2><dl><dt> <strong>Non-capturing Group</strong> <code>/(?:\s|\w)\d+/</code></dt><dd><p>    Just like <code>/(\s|\w)\d+/</code> but <code>(?: )</code>parentheses are
    non-capturing.
</p></dd><dt> <strong>Named Group</strong> <code>/(?:\s|\w)(?&lt;num>\d+)/</code> </dt><dd><p>    Captures <code>\d+</code> into <code>groups.num</code>.
</p></dd></dl><pre class="hljs language-javascript">> 'abc123'.match(/(?:\s|\w)(?&lt;num>\d+)/).groups 
[Object: null prototype] { num: '123' }
> 
</pre></section><section data-level="h2"><h2>Non-Greedy Quantifiers</h2><p>Normal quantifiers are greedy and attempt to match maximal text.  Make
quantifier <strong>non-greedy</strong> or <strong>lazy</strong> by suffixing quantifier with a <code>?</code>.
</p><pre class="hljs language-javascript">> 'abc123'.match(/(\w*)(\d+)/).slice(1)
[ 'abc12', '3' ]
> 'abc123'.match(/(\w*?)(\d+)/).slice(1)
[ 'abc', '123' ]
>
> '&lt;a> &lt;b>'.match(/\&lt;.*\>/)[0]
'&lt;a> &lt;b>'
> '&lt;a> &lt;b>'.match(/\&lt;.*?\>/)[0]
'&lt;a>'
>
</pre></section><section data-level="h2"><h2><code>RegExp()</code> Constructor</h2><ul><li><p>Constructor constructs a regex from a string.
</p></li><li><p>Can be used to build dynamic regex's depending on a variable.
</p></li><li><p>Suffers from <em>backslashitis</em>.
</p></li></ul><pre class="hljs language-javascript">> new RegExp('[abc]')
/[abc]/
> someVar = 'x'
'x'
> new RegExp(`${someVar}\\d`)
/x\d/
> new RegExp(`${someVar}\\\\\\d`)
/x\\\d/
>
</pre></section><section data-level="h2"><h2>More Regex Examples</h2><dl><dt> <code>/\d{1,3}(?:\.\d{1,3}){3}/</code> </dt><dd><p>    An IPv4 internet address.  Consists of 4 decimal numbers each
    containing up to 3 digits, separated by <code>.</code> characters.
</p></dd><dt> <code>/\/\/.*/</code> </dt><dd><p>    A JavaScript single-line comment. 2 forward slashes followed by
    zero-or-more characters other than newline.
</p></dd><dt> <code>/[-+]?\d+(?:\.\d+)?(?:[eE][-+]?\d+)?/</code> </dt><dd><p>    An optionally signed integer or floating point literal.  The integer
    part must be present.  It may be optionally followed by a fraction
    part which consists of a decimal point followed by one-or-more
    digits.  That too may optionally be followed by an exponent part which
    consists of either an <code>e</code> or an <code>E</code> followed by an optional sign,
    followed by one-or-more digits.
</p></dd></dl></section><section data-level="h2"><h2>Regex Flags</h2><p>Specify flags after closing slash when using literal syntax or as a
string second argument to <code>RegExp()</code> constructor:
</p><dl><dt> <code>/hello/i</code> </dt><dd><p>    Case-insensitive.  Equivalent to <code>[hH][eE][lL][lL][oO]</code>.
</p></dd><dt> <code>/hello/g</code> </dt><dd><p>    Global search or replace.  Start search from index of last match
    of this regex in string.
</p></dd><dt> <code>/^\#.*$/m</code> </dt><dd><p>    Multiline flag changes <code>^</code> and <code>$</code> to match only at the
    start/end of a <strong>line</strong>.
</p><p>    Example gives a single-line comment starting with a <code>#</code>-character
    in column 1 at the start of a line and continuing until the end of
    the line.
</p></dd></dl><p>Unfortunately, no way to include ignored formatting whitespace within
regex like the <strong>verbose</strong> <code>/x</code> flag available in other languages like
Python or Ruby.
</p></section><section data-level="h2"><h2>String <code>matchAll()</code> Method</h2><p>Like <code>match()</code>, but returns iterator over <strong>all</strong> matches.  Must use
global <code>g</code> flag.
</p><pre class="hljs language-javascript">> regex = /(?&lt;x>\w+?)(?&lt;y>\d+)/g
> m = ' prj1, hw2 ## #quiz1 '.matchAll(regex)
Object [RegExp String Iterator] {}
> for (const a of m) {
    console.log(a.groups.x, a.groups.y);
  }
prj 1
hw 2
quiz 1
undefined
> 
</pre></section><section data-level="h2"><h2>matchAll() Iterator to Array</h2><p>Can spread iterator returned from <code>matchAll()</code> into an array
to get access to array methods.
</p><pre class="hljs language-javascript">> regex = /(?&lt;x>\w+?)(?&lt;y>\d+)/g
/(?&lt;x>\w+?)(?&lt;y>\d+)/g
> m = ' prj1, hw2 ## #quiz1 '.matchAll(regex)
Object [RegExp String Iterator] {}
> m.map(x => x.groups)
Uncaught TypeError: m.map is not a function
> [...m].map(x => x.groups)
[
  [Object: null prototype] { x: 'prj', y: '1' },
  [Object: null prototype] { x: 'hw', y: '2' },
  [Object: null prototype] { x: 'quiz', y: '1' }
]
>
</pre></section><section data-level="h2"><h2>String <code>replace()</code> Method</h2><pre>string.replace(substr|regex, replacement|function)
</pre><p><code>replacement</code> can contain:
</p><dl><dt> <code>$$</code> </dt><dd><p>    Inserts a <code>$</code>.
</p></dd><dt> <code>$&amp;</code> </dt><dd><p>    Inserts match.
</p></dd><dt> <code>$`</code> </dt><dd><p>    Inserts portion of <code>string</code> before match.
</p></dd><dt> <code>$'</code> </dt><dd><p>    Inserts portion of <code>string</code> after match.
</p></dd><dt> <code>$</code>  <code>n</code> </dt><dd><p>    Inserts text matched by <em>n</em>'th capturing parentheses in <code>regex</code>.
</p></dd></dl></section><section data-level="h2"><h2>String <code>replace()</code> Examples</h2><pre class="hljs language-javascript">> 'the dog'.replace('dog', 'cat')
'the cat'
> 'the Dog'.replace(/dog/i, 'cat')
'the cat'
> 'the dog'.replace(/[aeiou]/, '')
'th dog'
> 'the dog'.replace(/[aeiou]/g, '')
'th dg'
> 'the dog123 fido; cat99 eve'.
    replace(/([^\d\s]+)(\d+)/g, '$1-$2')
'the dog-123 fido; cat-99 eve'
</pre></section><section data-level="h2"><h2>String <code>replace()</code> Examples Continued</h2><pre class="hljs language-javascript">> '0 cats, 1 cat, 7 cats'.replace(/\d+/,
     function(match) {
       const n = Number(match);
       if (n === 0) {
         return 'zero';
       }
       else if (n === 1) {
         return 'one';
       }
       else {
         return 'many';
       }
   })
'zero cats, 1 cat, 7 cats'
>
</pre></section><section data-level="h2"><h2>String <code>replace()</code> Examples Continued</h2><pre class="hljs language-javascript">> '0 cats, 1 cat, 7 cats'.replace(/\d+/g,
     function(match) {
       const n = Number(match);
       if (n === 0) {
         return 'zero';
       }
       else if (n === 1) {
         return 'one';
       }
       else {
         return 'many';
       }
   })
'zero cats, one cat, many cats'
>
</pre></section><section data-level="h2"><h2><code>RegExp</code> Methods</h2><dl><dt> <code>exec(str)</code> </dt><dd><p>    Searches for match of this in String <code>str</code>.  Return value
    similar to <code>String.prototype.match()</code>.  Traditionally used
    with a global regexp with flag <code>/g</code> to match repeatedly in
    a loop:
</p><pre class="hljs language-javascript">    const regex = /.../g;
    let m;
    while ( (m = regex.exec(str)) ) { ... }
</pre></dd><dt> <code>test(str)</code> </dt><dd><p>    Searches for match of this in String <code>str</code>.  Returns
    <code>true</code> if search successful, <code>false</code> otherwise.
</p></dd></dl></section><section data-level="h2"><h2>RegExp Limitations</h2><ul><li><p>Standard regular expressions cannot be used to recognize
    nested constructs for an arbitrary nesting depth.
</p></li><li><p>For example, it is not possible to write a regex for strings of
    balanced parentheses like <code>'((()))'</code> for an arbitrary depth of
    nesting.
</p></li><li><p>Colloquially, regex's cannot <strong>count</strong>.
</p></li><li><p>It is always possible to write a regex for a nested construct when
    the maximum depth of nesting is bounded.  For example, all
    strings of balanced parentheses of depth upto 2 can be
    written by simply enumerating all possibilities:
</p><pre>    /( \( ( \(\) )* \) )*/
</pre><p>    where the whitespace is used only for formatting and should be
    ignored.
</p></li></ul></section><section data-level="h2"><h2>RegEx Denial of Service</h2><p> <a href="https://en.wikipedia.org/wiki/ReDoS">Wikipedia</a>
</p><pre class="hljs language-javascript">> function time(fn) {
    t0 = Date.now(); fn(); return Date.now() - t0;
  }
> re = /^(a|aa)+$/
/^(a|aa)+$/
> time(() => ('a'.repeat(30) + 'c').match(re))
18
> time(() => ('a'.repeat(40) + 'c').match(re))
1835
> time(() => ('a'.repeat(46) + 'c').match(re))
32408
>
</pre></section><section data-level="h2"><h2>Crawler</h2><ul><li><p>Hardcoded to crawl only cs544 website.
</p></li><li><p>Does not crawl links inserted dynamically by JavaScript.
</p></li><li><p>Look for <code>href=</code> links.  Does so in a <code>matchAll()</code> loop using a
    global regex specified using the <code>g</code> flag (could also use
    RegExp <code>exec()</code>).
</p></li><li><p>Also uses regex's to extract a page title if possible.
</p></li><li><p>For each referenced page we track its url, title and referers.
</p></li><li><p>Uses a BFS <code>toDos</code> agenda.  URL put onto agenda only if it is
    new, extends the start cs544 start URL and looks like a HTML
    url.
</p></li><li><p> <a href="code/crawler/index.html">Running App</a>,
     <a href="code/crawler/src/index.ts?lang=ts">code</a>.
</p></li></ul></section><section data-level="h2"><h2>References</h2><ul><li><p> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">MDN</a>
</p></li><li><p> <a href="http://www.regular-expressions.info/">Regular-Expressions.info</a>
</p></li><li><p>Jeffrey E. F. Friedl, <em>Mastering Regular Expressions</em>, 3rd
    Edition, O'Reilly, 2006.
</p></li></ul></section></section></div>
    </div>

    <script type="module" src="../../assets/scripts/slide-controls.mjs"></script>
    <script type="module" src="../../assets/scripts/nav.mjs"></script> 
    <script type="module" src="../../assets/scripts/highlight.mjs"></script>
</body>
</html>

