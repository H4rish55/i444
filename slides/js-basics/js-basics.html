<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>JavaScript   Basics</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script type="text/javascript"
          src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js">
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github.min.css">
    <link href="../../assets/styles/article.css" rel="stylesheet" type="text/css" /> 
</head>

<body class=umt-slides>

    <nav id="course-nav">
      <ul>
      </ul>
    </nav>
    
    <div class="umt-content">
      <div><section data-level="h1"><h1>JavaScript   Basics</h1><section data-level="h2"><h2>Common JavaScript Data Types</h2><ul><li><p><strong>Numbers</strong> (no integers).  Arithmetic based on 64-bit IEEE-754 standard.
</p></li><li><p><strong>Strings</strong>.
</p></li><li><p><code>undefined</code> and <code>null</code>.
</p></li><li><p><strong>Booleans</strong>: <code>true</code> and <code>false</code>.  
</p></li><li><p>Objects (which include arrays and functions).
</p></li></ul><p>Objects are non-primitive.  All other types are primitive types.
</p></section><section data-level="h2"><h2>Numbers</h2><p><strong>No integers</strong> in early JS; problematic for financial calculations.
</p><pre class="hljs language-javascript">$ node
> 1/0
Infinity
> 0/0
NaN
> NaN === NaN //IEEE behavior; in other languages too
false
> 2**53  //** is exponentiation operator
9007199254740992
> 2**53 + 1
9007199254740992  //IEEE 64 bit floats have a 53-bit mantissa.
> (2**53 + 1) === 2**53
true
> Number.MAX_SAFE_INTEGER
9007199254740991
> BigInt(2**53) + 1n //now JS supports exact big integers
9007199254740993n
</pre></section><section data-level="h2"><h2>Normal Arithmetic and Bitwise Operators</h2><ul><li><p>Usual  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators">arithmetic operators</a> <code>+</code> (both infix and prefix), <code>-</code>
    (both infix and prefix), <code>*</code>, <code>/</code> and <code>%</code> (remainder, <strong>has
    sign of dividend</strong>), <code>**</code> (power).
</p></li><li><p> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">Bitwise operators</a> <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>>></code> (arith), <code>>>></code>
    (logical).
</p></li><li><p>Bitwise operators first convert operands to 32-bit 2's-complement
    integers.
</p></li><li><p>[Previous property was used in obsolete 
    <a href="http://asmjs.org/">asm.js</a> to obtain access to more efficient machine integer
    operations.]
</p></li></ul></section><section data-level="h2"><h2>Arithmetic Operators Examples</h2><pre class="hljs language-javascript">> 123_456*2        //'_' allowed for readability
246912
> -77%13           //% has sign of dividend
-12
> 77%-13
12
> -65%13
-0                 //IEEE-754 has both +0 and -0
> 2**2**3          //** is right associative
256
> (2**2)**3
64
> 18*2 + 77%13 / 2 //other binary operators left assoc
42
</pre></section><section data-level="h2"><h2>Bitwise Operators Examples</h2><pre class="hljs language-javascript">> 1 | 2	     //bitwise-or
3
> 0x99 &amp; 0x3 //bitwise-and; hex notation
1
> 5 ^ 7      //bitwise-xor
2
> ~0	     //bitwise-complement
-1   	     //0xffffffff is -1
> 3 &lt;&lt; 4     //left-shift
48     	     //x &lt;&lt; n === x * 2**n
> 100 >> 3   //arithmetic right-shift
12    	     // x >> n === x / 2**n
>
</pre></section><section data-level="h2"><h2>More on Shift Operators</h2><ul><li><p>Shift operators can be used to multiply (left-shift) and
    divide (right-shift) by powers-of-2.
</p></li><li><p>Distinguish between <code>>></code> (sign-propagating or arithmetic
    right-shift) and <code>>>></code> (zero-fill or logical right-shift).  No
    difference for non-negative numbers, but different results for
    negative numbers:
</p></li></ul><pre class="hljs language-javascript">> -9 >> 1
-5
> -9 >>> 1
2147483643
> (-9 >>> 1).toString(16)
'7ffffffb'
>
</pre></section><section data-level="h2"><h2>Strings</h2><ul><li><p> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">Strings</a> are immutable.
</p></li><li><p>Classically, string literals are delimited using either double
    quotes <code>&quot;</code> or single quotes <code>'</code>.  Prefer <code>'</code> delimiters since
    easier to type on normal keyboards.  Backslashes interpreted as
    usual. Cannot span multiple lines.
</p></li></ul><pre class="hljs language-javascript">> 'a' + 'b'    //string concatenation
'ab'
> 'abc'[1]     //indexing: results in string of length 1
'b'            //no char type
> 'hello world'.indexOf('o')
4
> 'hello world'.lastIndexOf('o')
7
> 'hello world'.substr(3, 4)  //args: (startIndex, length)
'lo w'                        //treat as legacy function
</pre></section><section data-level="h2"><h2>Strings Continued</h2><pre class="hljs language-javascript">> 'hello world'.substring(3, 4) //args:(startIndex, endIndex)
'l'                             //swaps args if wrong order
                                //avoid using
> 'hello world'.slice(6)
'world'
> 'hello world'.slice(1, 4) //args: (startIndex, endIndex)
'ell'
> 'hello world'.slice(-3) //index from right; -1 is rightmost
'rld'
> 'hello world'.slice(-3, -1)
'rl'
</pre></section><section data-level="h2"><h2>Template String Literals</h2><p>Enclosed within back-quotes <code>`</code>.  Relatively new addition.  Can
contain direct newlines.  All popular scripting languages have similar
concepts (though introduced relatively recently to Python).
</p><pre class="hljs language-javascript">> const x = 22
undefined
> `The answer is ${x + 20}`
'The answer is 42'
> `Betty bought a bit of butter
... `
'Betty bought a bit of butter\n'
> `Twas brillig and the slithy toves
... Did gyre and gimble in the wabe:`
'Twas brillig and the slithy toves\nDid gyre and gimble in the wabe:'
> 
</pre></section><section data-level="h2"><h2><code>undefined</code></h2><dl><dt><code>undefined</code></dt><dd><p>     Means lack of a value.
</p><ul><li><p>Uninitialized variables are <code>undefined</code>.
</p></li><li><p>Missing parameters are <code>undefined</code>.
</p></li><li><p>Non-existent properties are <code>undefined</code>.
</p></li><li><p>Functions return <code>undefined</code> if no explicit return value.
</p></li><li><p>Use <code>x === undefined</code> to check if <code>x</code> is undefined.
</p></li></ul></dd></dl></section><section data-level="h2"><h2><code>undefined</code> Continued</h2><pre class="hljs language-javascript">	 > let x         //statement
	 undefined       //statement has no value
	 > x             //expression
	 undefined       //value of expression
         > x = {}        //assignment expr; empty object
         {}
         > x.a
         undefined
	 > undefined
	 undefined
	 > undefined = 1 //not a reserved word
	 1
	 > undefined     //immutable in global scope
	 undefined
</pre></section><section data-level="h2"><h2><code>null</code></h2><p><code>null</code> is a special value used to denote <em>no object</em>.
</p><p>Can be used wherever an object is expected to indicate absence of
an object.  Examples:
</p><ul><li><p>Parameters.
</p></li><li><p>Last object in a object chain.
</p></li><li><p>Use <code>x === null</code> to check if <code>x</code> is null.
</p></li></ul></section><section data-level="h2"><h2>Problems with <code>null</code></h2><p>Programmers are really sloppy with <code class="hljs language-javascript">null</code>:
</p><ul><li><p>Tony Hoare has called <code class="hljs language-javascript">null</code> his
    
    <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">billion dollar mistake</a>.
</p></li><li><p>Oracle does not distingush between <code class="hljs language-javascript">null</code> and an empty string!
</p></li><li><p> <a href="https://www.wired.com/2015/11/null/">Wired story</a> on living
    with a last name <strong>Null</strong>.
</p></li><li><p> <a href="https://www.wired.com/story/null-license-plate-landed-one-hacker-ticket-hell/">NULL</a> license plate problems.
</p></li><li><p>Modern trend in programming is to document values which may be
    <code class="hljs language-javascript">null</code> by wrapping them within some kind of <code class="hljs language-javascript">Maybe</code> or <code class="hljs language-javascript">Option</code>
    object.  In order to access the non-<code></code><code class="hljs language-javascript">null</code> value, user of
    these wrappers is forced to check for <code class="hljs language-javascript">null</code>.
</p><p>    A program written in this style should never see a <code>null</code>;
    a <code>null</code> would indicate a program bug.  Gets rid of the
    repeated checking for <code>null</code> code smell.
</p></li></ul></section><section data-level="h2"><h2><code>typeof</code></h2><p>Operator <code>typeof</code> used for categorizing <strong>primitives</strong>:
</p><pre class="hljs language-javascript">> typeof null
'object'
> typeof undefined
'undefined'
> typeof &quot;&quot;
'string'
> typeof 1
'number'
> typeof 1.2
'number'
> typeof true
'boolean'
</pre></section><section data-level="h2"><h2><code>typeof</code> Continued</h2><pre class="hljs language-javascript">> typeof {}  //empty object literal
'object'
> typeof []  //empty array literal
'object'
> typeof (new Date())
'object'
>
</pre><p>Do not confuse with TypeScript's <code>typeof</code> operator which can be
used within a type context.
</p></section><section data-level="h2"><h2><code>instanceof</code></h2><p>The <code>typeof</code> operator does not distinguish between different object
types.  Use <code>instanceof</code> operator for categorizing objects.  The
expression <em>v</em> <code>instanceof</code> <em>Type</em> returns true iff <em>v</em> is an
instance of <em>Type</em>.
</p><pre class="hljs language-javascript">> ({} instanceof Object)
true
> [] instanceof Array
true
> [] instanceof Object
true
> (new Date()) instanceof Date
true
> (new Date()) instanceof Array
false
> (new Date()) instanceof Object
true
</pre></section><section data-level="h2"><h2>What is Truth</h2><p>Many languages, particularly scripting languages, treat some set
of values as <em>false</em> and <strong>all other values</strong> as <em>true</em>.
</p><p>The <em>falsy</em> values in js are the following:
</p><ol><li><p><code>undefined</code>.
</p></li><li><p><code>null</code>.
</p></li><li><p><code>false</code>.
</p></li><li><p><code>0</code>.
</p></li><li><p><code>&quot;&quot;</code> (empty string).
</p></li><li><p><code>NaN</code> (Not-a-Number).
</p></li></ol><p>All other values are <em>truthy</em> and considered equivalent to true when used in a
boolean context.
</p></section><section data-level="h2"><h2>Comparison Operators</h2><ul><li><p>Equality checking operators <code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>.  <strong>Only use
    the last two</strong>.
</p></li><li><p><code>></code>, <code>&lt;</code>, <code>>=</code>, <code>&lt;=</code> can be used with both numbers and strings.
</p></li><li><p>Objects compared by identity.
</p></li></ul><pre class="hljs language-javascript">> 12.2 &lt; 12.1
false
> 1 == true     //surprise: DO NOT USE!!
true
> 1 === true    //less surprising
false
> 'abc' &lt; 'ab'
false
> 'abc' &lt; 'abcd'
true
> {} === {}
false
</pre></section><section data-level="h2"><h2>Logical Operators</h2><ul><li><p>Logical operators <code>!</code> returns a strict boolean value 
    (true or false).
</p></li><li><p>short-circuit <code>&amp;&amp;</code> and short-circuit <code>||</code> 
    return falsy/truthy values (last value evaluated).
</p></li></ul><pre class="hljs language-javascript">> !true
false
> !1
false
> !!1  //common idiom used to convert to proper boolean
true
> !!0
false
</pre></section><section data-level="h2"><h2>Logical Operators Continued</h2><pre class="hljs language-javascript">> 'hello' || 'world'
'hello'
> 'hello' &amp;&amp; 'world'
'world'
</pre></section><section data-level="h2"><h2>Default Values</h2><p>Common idiom for default initialization:
</p><pre class="hljs language-javascript">> let x
undefined
> let y = x || 42
undefined
> y
42
</pre><p>But problematic because reasonable values like <code>0</code>, <code>''</code> and <code>false</code>
are falsy values:
</p><pre class="hljs language-javascript">> x = 0
undefined
> y = x || 42
42  //y assigned 42 even tho' x has a reasonable value
</pre></section><section data-level="h2"><h2>Logical Operators Continued</h2><p>Default initialization idiom should only be used if a valid value
is not one of the falsy values.
</p><pre class="hljs language-javascript">> x = 0  //0 is falsy
0
> let z = x || defaultValue
undefined
> z 
42 //z assigned defaultValue despite x having value 0
</pre></section><section data-level="h2"><h2>Nullish Coalescing Operator</h2><p> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_Coalescing_Operator">nullish coalescing operator</a> <code>??</code> returns
right operand when left operand is <strong>nullish</strong>, i.e. <code class="hljs language-javascript">null</code> or <code class="hljs language-javascript">undefined</code>,
otherwise it returns its left operand (relatively new addition to JavaScript):
</p><pre class="hljs language-javascript">> x = 0
0
> y = x ?? 42
0
> x = undefined
undefined
> y = x ?? 42
42
</pre><p>Modern way to do default initialization.
</p></section><section data-level="h2"><h2>Optional Object Chaining</h2><p>When chaining accesses, we often need to check that intermediate
values are not <strong>nullish</strong> (i.e. <code class="hljs language-javascript">null</code> or <code class="hljs language-javascript">undefined</code>).
</p><pre class="hljs language-javascript">const c = obj &amp;&amp; obj.a &amp;&amp; obj.a.b &amp;&amp; obj.a.b.c;
</pre><p>Can be done more compactly using new feature
 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optional chaining</a> <code>.?</code> operator:
</p><pre class="hljs language-javascript">const c = obj?.a?.b?.c;  //undefined if any accessor nullish
</pre><p>Syntax also allows:
</p><pre class="hljs language-javascript">a?.[expr]       //dynamic property name
f?.(arg1, arg2) //returns undefined if f nullish
</pre></section><section data-level="h2"><h2>Control Constructs</h2><ul><li><p>
     <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else">Condition-based selection</a> using <code class="hljs language-javascript">if</code> and <code class="hljs language-javascript">if-else</code> statements.
     No surprises except truthy interpretation of condition.
</p></li><li><p>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch">Multiway selection</a> on a value (including string values) using
    <code class="hljs language-javascript">switch-case-default</code>.  Value compared with <code class="hljs language-javascript">case</code>-values using
    <code>===</code>.  
</p><p>    <strong>Warning</strong>: Control will fall-through from one <code class="hljs language-javascript">case</code> to the next,
    unless there is an intervening <code class="hljs language-javascript">break</code> statement.
</p></li><li><p>Looping using  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/while">while.</a>  Body may not execute at all if condition
    is initially falsy.
</p></li><li><p>Looping using
    
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/do...while">do-while</a> statement executes its body at least once, irrespective
    of the value of the condition.
</p></li></ul></section><section data-level="h2"><h2>For Loops</h2><ul><li><p>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for">Traditional for</a> loop with initialization expression, condition
    expression and update expression.  Any of the three expressions can
    be omitted.
</p></li><li><p>Looping through  
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in">object properties</a> using <code class="hljs language-javascript">for-in</code>.
</p></li><li><p>Looping over  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">iterable objects</a> like arrays using <code class="hljs language-javascript">for-of</code>.
</p></li></ul></section><section data-level="h2"><h2>For Loop Examples</h2><p>Summing positive elements of array <code>a</code> (better to use <code>filter</code> and <code>reduce</code>):
</p><p>Using traditional <code class="hljs language-javascript">for</code>:
</p><pre class="hljs language-javascript">let sum = 0;
for (let i = 0; i &lt; a.length; i++) {
  if (a[i] > 0) sum += a[i];
}
</pre><p>Using <code class="hljs language-javascript">for-of</code>:
</p><pre class="hljs language-javascript">let sum = 0;
for (const v of a) {
  if (v > 0) sum += v;
}
</pre></section><section data-level="h2"><h2>Loop Choice</h2><p>Always use loop which moves as much of loop control into loop header; do
so at the highest level of abstraction.  In descending order of preference:
</p><ul><li><p>Looping through array: use <code class="hljs language-javascript">for-of</code>.  Looping through object
    properties: use <code class="hljs language-javascript">for-in</code>.
</p></li><li><p>Looping through integer range: use traditional <code class="hljs language-javascript">for</code>.
</p></li><li><p>Body executed at least once: use <code class="hljs language-javascript">do-while</code>.
</p></li><li><p>Plain <code class="hljs language-javascript">while</code> loop is most general; lowest preference since loop
    update hidden within loop body.
</p></li></ul></section><section data-level="h2"><h2>Functions</h2><ul><li><p>Functions are <strong>first-class</strong>: need not have a name (<em>anonymous</em>),
    can be passed as parameters, returned as results, stored
    in data structure.
</p></li><li><p>Functions can be nested within one another.
</p></li><li><p><strong>Closures</strong> preserve the referencing environment of a function.
</p></li><li><p>During execution of a function, there is always an implicit
    object, referred to using <code>this</code>.  The word <code>this</code> will be
    pronounced <code>self</code> when speaking.
</p></li></ul></section><section data-level="h2"><h2>Function Definitions</h2><ul><li><p>Traditional function definitions
</p><pre class="hljs language-javascript">    function max1(a, b) { return a > b ? a : b }
</pre></li><li><p>Anonymous function using <code class="hljs language-javascript">function</code> keyword
</p><pre class="hljs language-javascript">    max2 = function(a, b) { return a > b ? a : b }
</pre></li><li><p>Anonymous fat-arrow function
</p><pre class="hljs language-javascript">    > x = max4 = (a, b) => a > b ? a : b
    > (a => { const v = max4(a, 42); 
              return v * 2; 
            }
      )(5)  //IIFE
    84
</pre></li><li><p>Subtle differences in semantics.
</p></li></ul></section><section data-level="h2"><h2>Arrays</h2><p> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Arrays</a> 
(AKA lists) are like objects except:
</p><ul><li><p>It has an auto-maintained <code>length</code> property (always set to 1 greater
    than the largest array index).
</p></li><li><p>Arrays have their prototype set to <code>Array.prototype</code> ( 
    <code>Array.prototype</code> has its prototype set to <code>Object.prototype</code>,
    hence arrays inherit object methods).
</p></li><li><p>Rich set of methods.  Some like
    
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push">push(),</a>
    
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">sort(),</a>
    
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse">reverse()</a> are mutable.  Others like  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat">concat(),</a> the newer
    
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted">toSorted()</a> and
    
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed">toReversed()</a> are not.
</p></li></ul></section><section data-level="h2"><h2>Array Examples</h2><pre class="hljs language-javascript">> a = []
[]
> a[999] = 22
22
> a
[ &lt;999 empty items>, 22 ]
> a[999]
22
> a.length = 1   //truncates
1
> a[999]
undefined
</pre></section><section data-level="h2"><h2>Array Examples Continued</h2><pre class="hljs language-javascript">> a[2] = 22
22
> a.length
3
> a.join('|')
'||22'
> a.x = 99  //arrays are objects: can have properties
99
> a
[ &lt;2 empty items>, 22, x: 99 ]
> a.constructor
[Function: Array]
> 
</pre></section><section data-level="h2"><h2>Spreading Arrays</h2><p>Arrays can be spread into array literals or function calls 
using the <code>...</code> <strong>spread</strong> operator:
</p><pre class="hljs language-javascript">> a = [3, 4, 5]
[ 3, 4, 5 ]
> [33, 44, ...a, 66]
[ 33, 44, 3, 4, 5, 66 ]
> ((a, b) => a * b)(a)
NaN
> ((a, b) => a * b)(...a)
12
> ((a, b) => a * b)(5, ...a)
15
> [x, y] = a
[ 3, 4, 5 ]
> [x, y]
[ 3, 4 ]
> [x, ...y] = a
[ 3, 4, 5 ]
> [x, y]
[ 3, [ 4, 5 ] ]
</pre></section><section data-level="h2"><h2>Mapping Arrays</h2><p>The <code>map()</code> function returns a new array which is the result of
calling its argument function on each element of the calling array.
</p><pre class="hljs language-javascript">> function times3(x) { return 3*x; }
undefined
> [1, 2, 3].map(times3)
[ 3, 6, 9 ]
> [1, 2, 3].map(x => 7*x);
[ 7, 14, 21 ]
> [7, 3, 2, 4].map(x => x % 2 === 0) 
[ false, false, true, true ]
>
</pre></section><section data-level="h2"><h2>Reducing Arrays</h2><p>The <code>reduce()</code> function using a function <code>f(accumulator, element)</code> to
reduce an array to a single value (often called
 <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)">fold</a> in
other languages).
</p><pre class="hljs language-javascript">> [1,2,3,4,5].reduce((acc, value) => acc + value)
15
> [1,2,3,4,5].reduce ((acc, value) => acc + value, 7 )
22
> [12].reduce((acc, value) => acc + value)
12
> > [].reduce((acc, value) => acc + value, 15)
15
> [].reduce((acc, value) => acc + value)
TypeError: Reduce of empty array with no initial value
...
</pre></section><section data-level="h2"><h2>Applying a Function to Each Array Element</h2><p><code>forEach()</code> applies function to each element.  Like many other array
functions, the callback takes 3 arguments: <code class="hljs language-javascript">elementValue</code>, <code class="hljs language-javascript">elementIndex</code>
plus full array.
</p><pre class="hljs language-javascript">indexes = []
[]
> [1, 2, 3, 4].forEach(( v, i ) => {
    if (v%2 === 0) indexes.push (i);
   })
undefined
> indexes
[ 1, 3 ]
>
</pre><p>Basically a loop; hence it does not make sense if the function does not
have a side-effect like I/O, or changing a non-local variable (as in the
example above).
</p></section><section data-level="h2"><h2>Other Higher-Order Array Functions</h2><p>Includes <code>every()</code>, <code>find()</code>, <code>findIndex()</code>, <code>filter()</code>,
<code>reduceRight()</code>, <code>some()</code>.
</p><pre class="hljs language-javascript">> [1, 2, 3, 4].find(x => x%2 === 0)
2
> [1, 2, 3, 4].findIndex(x => x%2 === 0)
1
> [1, 2, 3, 4].every(x => x%2 === 0)
false
> [1, 2, 3, 4].some(x => x%2 === 0)
true
> [1, 2, 3, 4].reduce((acc, v) => acc - v)
-8             //((1-2)-3)-4
> [1, 2, 3, 4].reduceRight((acc, v) => acc - v)
-2             //1-(2-(3-4))
>
</pre></section><section data-level="h2"><h2>Some More Examples</h2><p>Examples of operating on arrays without destructive assignment, loops
or recursion:
</p><ul><li><p>Summing positive elements of array:
</p><pre class="hljs language-javascript">    > [1, -2, 3, -4].filter((e) => e > 0).
        reduce((acc, e) => acc + e, 0)
    4
</pre></li><li><p>Sum of first \(\;n\) squares:
</p><pre class="hljs language-javascript">    > Array.from({length: 10}) //10 undefined elements
        .map((_, i) => (i + 1)**2) //1, 4, 9, 16, ... 100
        .reduce((acc, a) => acc + a) //sum up
    385

    //checking result using a loop:
    > s = 0; for (let i = 1; i &lt;= 10; i++) { s += i*i; }; s
    385
</pre></li></ul></section><section data-level="h2"><h2> <span id="fib">Fibonacci</span> without destructive assignment or recursion</h2><pre class="hljs language-javascript">  //return list of first n Fibonacci numbers
> function fib(n) { 
    return Array.from({length: n - 2}) //n - 2 undefined values
      .reduce((acc, _) => acc.concat(acc.at(-1) + acc.at(-2)), 
              [1, 1]); 
  }
undefined
> fib(10)
[
   1,   1,  2,  3,  5,
   8,  13, 21, 34, 55
]
>
</pre><ul><li><p><code class="hljs language-javascript">acc</code> initialized to [1, 1].
</p></li><li><p>For each (n - 2) undefined array element, concatenate
    <code class="hljs language-javascript">acc.at(-1) + acc.at(-2)</code> to <code class="hljs language-javascript">acc</code>. 
</p><pre class="hljs language-javascript">    [1, 1]
    [1, 1].concat(acc.at(-1) + acc.at(-2)) === [1, 1, 2]
    [1, 1, 2].concat(acc.at(-1) + acc.at(-2)) === [1, 1, 2, 3]
    [1, 1, 2, 3].concat(acc.at(-1) + acc.at(-2)) 
        === [1, 1, 2, 3, 5]
    ...
</pre><p>    See  <a href="https://www.youtube.com/watch?v=qaGjS7-qWzg">HTTP 203: Is
    reduce() bad?</a> for why this style of programming is probably not
    a good idea for real code.
</p></li></ul></section><section data-level="h2"><h2>Function Arguments</h2><ul><li><p>No requirement that number of actual arguments agree with
    the number of declared formal parameters.
</p></li><li><p>If the number of actual arguments is greater than the number of
    formal parameters, then the extra arguments are ignored:
</p><pre class="hljs language-javascript">    > ((a, b) => a + b)(3, 4, 5)
    7
</pre></li><li><p>If the number of actual arguments is less than the number of
    formal parameters, then the extra formal parameters are
    <code class="hljs language-javascript">undefined</code>.  Dangerous!!
</p><pre class="hljs language-javascript">    > ((a, b) => a > b)(3)
    false
</pre></li><li><p>The <code>length</code> of a function is its number of declared formal
    parameters:
</p><pre class="hljs language-javascript">    > ((a, b) => a > b).length
    2
</pre></li></ul></section><section data-level="h2"><h2>Accessing Actual Arguments</h2><ul><li><p>The actual arguments to a function defined using the <code class="hljs language-javascript">function</code>
    keyword (not fat-arrow functions) are accessible using a pseudo
    variable <code>arguments</code>:
</p><pre class="hljs language-javascript">    > (function() { return arguments.length ; })(3, 7)
    2
</pre></li><li><p>The <code>arguments</code> pseudo-variable is <strong>array-like</strong>; it supports
    <code>length</code> and indexing operations but is not a real array.
</p><pre class="hljs language-javascript">    > (function() { return -arguments[0] ; })(3, 7)
    -3
    > ( function() { 
          return arguments.map(x => x + 1); 
        }
      )(3, 7)
    Uncaught TypeError: arguments.map is not a 
                        function
</pre></li></ul></section><section data-level="h2"><h2>Converting <code>arguments</code> to a Real Array</h2><ul><li><p><code>arguments</code> can be converted to a real array by being <strong>spread</strong>
    into a real array:
</p><pre class="hljs language-javascript">    > ( function() { 
          return [...arguments].map(x => x + 1); 
        }
      )(3, 7)
    [ 4, 8 ]
</pre></li><li><p>Alternately, use <code>Array.from(arguments)</code>:
</p><pre class="hljs language-javascript">    > ( function() { 
          return Array.from(arguments)
            .reduce((acc, x) => Math.max(acc, x)); 
        }
      )(3, 7, 2, 11, 5)
    11
</pre></li><li><p>A common idiom used in legacy JS applications was
    <code class="hljs language-javascript">Array.prototype.slice(arguments)</code>.
</p><pre class="hljs language-javascript">    > ( function() { 
          return Array.prototype.slice.call(arguments)
            .findIndex(x => x % 2 === 0);
        }
      )(3, 7, 2, 11, 5)
    2
</pre></li></ul></section><section data-level="h2"><h2>Function Parameters in Modern JavaScript</h2><ul><li><p>Can provide default values for trailing parameters.  These
    values are evaluated for each call:
</p><pre class="hljs language-javascript">    > ((a, b=2, c=a*b) => a + b + c)(4)
    14
</pre></li><li><p>Modern JS needs to use <code>arguments</code> less; instead, if the
    last argument is preceeded by <code>...</code>, then all <strong>rest</strong>
    arguments are collected into that parameter as a <strong>real
    array</strong>.  Works with fat-arrow functions too!
</p><pre class="hljs language-javascript">    > (() => console.log(arguments))(1, 2, 3,4)
    Uncaught ReferenceError: arguments is not defined
    > ((...args) => console.log(args))(1, 2, 3,4)
    [ 1, 2, 3, 4 ]
    undefined
</pre></li></ul></section><section data-level="h2"><h2>Copying Objects</h2><ul><li><p>Assignment merely copies references.
</p><pre class="hljs language-javascript">      > obj1 = { a: 33, b: [44, 55], c: 'hello' }
      { a: 33, b: [ 44, 55 ], c: 'hello' }
      > obj2 = obj1
      { a: 33, b: [ 44, 55 ], c: 'hello' }
      > obj1.a = 44
      44
      > obj2  //assignment to obj1.a changed obj2
      { a: 44, b: [ 44, 55 ], c: 'hello' }
</pre></li><li><p>Using spread syntax makes a <strong>shallow copy</strong>:
</p><pre class="hljs language-javascript">      > obj2 = { ...obj1 }
      { a: 44, b: [ 44, 55 ], c: 'hello' }
      > obj1.a = 55
      55
      > obj2 //obj2 unchanged
      { a: 44, b: [ 44, 55 ], c: 'hello' }
      > obj1.b[0] = 33
      33
      > obj2  //assignment to obj1.b[0] changed obj2
      { a: 44, b: [ 33, 55 ], c: 'hello' }
</pre></li></ul></section><section data-level="h2"><h2>Copying Objects Continued</h2><ul><li><p>Until recently, the best way to get a deep copy was a hack:
</p><pre class="hljs language-javascript">    > obj2 = JSON.parse(JSON.stringify(obj1))
    { a: 55, b: [ 33, 55 ], c: 'hello' }
    > obj1.b[0] = 11
    11
    > obj2 //obj2 unchanged
    { a: 55, b: [ 33, 55 ], c: 'hello' }
    > obj1 //obj1 was changed
    { a: 55, b: [ 11, 55 ], c: 'hello' }
</pre><p>    Cannot be used to copy function objects.
</p></li><li><p>JS now supports a global
    
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone">structuredClone()</a> function:
</p><pre class="hljs language-javascript">    > obj2 = structuredClone(obj1)
    { a: 55, b: [ 11, 55 ], c: 'hello' }
    > obj1.b[0] = 99
    99
    > obj2  //unchanged
    { a: 55, b: [ 11, 55 ], c: 'hello' }
    > obj1  //changed
    { a: 55, b: [ 99, 55 ], c: 'hello' }
    > 
</pre></li></ul></section></section></div>
    </div>

    <script type="module" src="../../assets/scripts/slide-controls.mjs"></script>
    <script type="module" src="../../assets/scripts/nav.mjs"></script> 
    <script type="module" src="../../assets/scripts/highlight.mjs"></script>
</body>
</html>

