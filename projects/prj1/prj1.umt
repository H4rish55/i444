                      P r o j e c t   1

*Due*: Sep 30, before midnight.

*Important Reminders*:

   + As per the course
    .<../../misc/academic-honesty/academic-honesty-policy.html>
    "Academic Honesty Statement", cheating of any kind will minimally
    result in your letter grade for the entire course being reduced by
    one level.

  + If any use of AI is detected, you will receive a *zero* for the
    entire project.

This document first provides the aims of this project, followed by a
discussion of its background including relevance to future projects.
It then lists the requirements as explicitly as possible.  It then
hints at how these requirements can be met.

                        Aims
                        ====

The aims of this project are as follows:

  + To verify that you have GUI access to your VM.

  + To familiarize you with the development environment on your VM.

  + To encourage you to use advanced features of JavaScript and
    TypeScript in your code.

  + To give you superficial exposure to a no-sql database.



         		   Background
			   ==========

This project introduces a data model for a chat application and
requires you to persist that data model in a mongo database.

Specifically, the chat application is modeled as the three entities
shown below:

.image(src="figs/data-model.png", height=500)

  : `User` :
    This entity represents a user of the chat application.  A user has
    typical associated information like `firstName`, `lastName` and
    `email`.  A user also has a `chatName` which is the handle by
    which they are identified externally.

  : `ChatRoom` :
    Serves to gather related chat messages together.  It is identified
    externally by a `roomName` room-name and a `descr` description.

  : `ChatMsg` :
    This is the entity which provides the raison d'etre for the
    application and represents a chat message posted by a user in a chat-room.

It is worth emphasizing that the above data model is merely the
external view as seen by the users of the application.  In particular,
the associations must be preserved even if a user's `chatName` and a
room's `roomName` change.

The details of the data model are given in .<prj1-sol/src/lib/chat-types.ts?lang=ts> "chat-types.ts".

	    	        Future Projects
			---------------

In future projects, we will be extending this project in steps:

  + *Project 2*: Completing validation leftover from this project and
    exposing an API via web services.  Specifically, many of the types
    in .<prj1-sol/src/lib/chat-types.ts?lang=ts> "chat-types.ts" will
    be generated automatically from the validation requirements.

  + *Project 3*: Use the web services and
    .<https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events>
    "server-sent events" to get the guts of the application working in
    a browser.

  + *Projects 4* Completing the browser UI using a modern web framework
    like .<https://react.dev/> React.


                        .=require= Requirements
                        =======================
  
You must upload a .<https://linux.die.net/man/1/zip> "zip"-archive to
gradescope which unpacks into a `prj1-sol` directory, such that typing
`npm ci` within that directory followed by `npm run test` is
sufficient to run tests for your project.

Specifically, the `prj1-sol` directory must directly contain a
`README`, `package.json`, `package-lock.json`, `tsconfig.json` and
`vm.png` files.  It should not contain any `node_modules` or `dist`
directories.

You should not use any packages other than those mentioned explicitly
in the rest of this document.  (One specific exception: you may use
a UUID package if you decide to use UUID's to represent ID's).

What you specifically need to do is add code to the provided
.<./prj1-sol/src/lib/chat.ts?lang=ts> chat.ts and
.<./prj1-sol/src/lib/chat-dao.ts?lang=ts> chat-dao.ts source files so
as to implement the `Chat` interface documented in
.<./prj1-sol/src/lib/chat-types.ts?lang=ts> chat-types.ts.  The
implementation should pass all provided tests.  Additionally, you
are required to implement three additional tests.

Your project is required to report all errors with an error code and
suitable human readable message, though there is one notable
exception:

  + Entities which should exist not but do not: `E_NOT_FOUND`.

  + Entities which should not exist but do exist: `E_EXISTS`.

  + Database errors `E_DB`.

  + The one exception: you are not required to detect `E_BAD_VAL`
    errors like a malformed email address.  Those kind of errors will
    be handled in your next project.

The specific requirements on the API do not list specific error
code so as to allow you to decide what errors can occur (unfortunately,
the provided tests provide some answers).

All ID's generated by your project should usually be unique and hard
to guess.

The requirements on the project will be clearer by looking at
an .<extras/LOG?lang=sh> "annotated log".

Additionally, in order to avoid pain points in future projects, your
`submit/prj1-sol` *must* contain a top-level `vm.png` image file to
verify that you have set up your VM correctly.  Specifically, the
image must show an x2go client window running on your VM.  The
captured x2go window must show a terminal window containing the output
of the following commands:

.code(lang=sh)
```
$ hostname; hostname -I
$ ls ~/cs444
$ ls ~/i444
$ crontab -l | tail -3
```


	     	 	 Provided Files
			 ==============

The .<./prj1-sol> prj1-sol directory contains a start for your
project.

  + The .<prj1-sol/src/lib> src/lib directory contains the files
    which implement the guts of the project.

      : .<./prj1-sol/src/lib/chat.ts?lang=ts> chat.ts and
        .<./prj1-sol/src/lib/chat-dao.ts?lang=ts> chat-dao.ts : These
        skeleton files constitute the guts of your project.  The
        former wraps the latter.  You will need to flesh out the
        skeletons, adding code as per the documentation.  You should
        feel free to add any auxiliary type, function or method
        definitions as required.

      : .<prj1-sol/src/lib/chat-types.ts?lang=ts> chat-types.ts :
        A file providing a data types and type utility functions for
        this project.  Understanding this file is critical to this
        project.
    
        You should not need to modify this file.

  + The .<prj1-sol/src> src directory contains a command-line programs
    which allow you to exercise the API via the command-line.
    Specifically, .<prj1-sol/src/index.ts?lang=ts> index.ts and
    .<prj1-sol/src/main.ts?lang=ts> main.ts provide the command-line
    functionality.

  + The .<prj1-sol/src/test> test directory contains tests for this
    project.  Specifically,
    .<prj1-sol/src/test/mem-db-server.ts?lang=ts> mem-db-server.ts is
    a wrapper around
    .<https://github.com/typegoose/mongodb-memory-server>
    mongodb-memory-server provides an in-memory implementation of
    mongodb well suited for testing.  The actual tests are in
    .<prj1-sol/src/test/tst-chat.ts?lang=ts> tst-chat.ts.

    You will need to modify the latter file in order to implement
    several tests which have been marked `.todo()`.

     Note that the TA may choose to grade your project with
     additional or different tests.


  + The .<prj1-sol> prj1-sol directory contains top-level
    project files:

      : .<./prj1-sol/tsconfig.json?lang=json> tsconfig.json:
        A configuration file for typescript.  You may modify
        this file if necessary.

      : .<./prj1-sol/.gitignore> ".gitignore" :
        A `.gitignore` file set up to prevent committing the
        `node_modules` directory (containing downloaded packages),
        `dist` directory (containing compiled code) and emacs `*~`
        backup files into git.

        [This link does not work on the course website, but the file
        is present in the provided `prj1-sol` directory].


      : .<./prj1-sol/.zipignore> ".zipignore" :
        A `.zipignore` file for use by the
        .<../../bin/do-zip.sh?lang=sh> do-zip.sh shell script to avoid
        including the garbage files like the `node_modules` directory
        (containing downloaded packages), `dist` directory (containing
        compiled code) and emacs `*~` backup files.

      : .<./prj1-sol/README> README:
        A README file which must be submitted along with your project.
        It contains an initial header which you must complete (replace
        the dummy entries with your name, B-number and email address
        at which you would like to receive project-related email).
        After the header you may include any content which you would
        like read during the grading of your project.

  + The course .<../../lib> directory provides two libraries:

    : .<../../lib/node-utils> cs444-node-utils :
      Utilities useful for the node command-line.

    : .<../../lib/js-utils> cs444-js-utils : General JavaScript
      utilities.  In particular this library provides the
      .<../../lib/js-utils/src/lib/errors.ts?lang=ts> "error handling"
      discussed in class and used extensively in this and future
      projects.

The .<extras> directory contains an .<extras/LOG?lang=sh> "annotated LOG".

      	     	 	 Before You Begin 
			 ================

The following information may be useful to consider before starting
work on your project.

    	      		  TypeScript
			  ----------

Leverage the use of TS as much as possible to document
and validate your code.  Do not try to work around type
checking by declaring variables to have type `any`.  Some
points worth emphasizing:

  + Remember that TS types exists only at compile time and
    disappear completely at runtime.

  + TS types and JavaScript values do not intersect.

  + It is possible to get the TS type of a JavaScript
    value using the `typeof` operator.  For example:

    .code(lang=ts)
    ~~~
    const obj = { a: 33, b: 44, c: 55 };

    //following equiv to type Keys = 'a' | 'b' | 'c';
    type Keys = keyof typeof obj; 
    ~~~

  + TS is extremely competent at inferring types, but it occasionally
    loses type information and you will need to assist it with explicit
    declarations or casts using `as`.

  + Another situation where you can help TS is asserting that a value
    is not `null` or `undefined` using a postfix `!`
    .<https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix->
    "non-null assertion", as in:

    ~~~
    let date?: Date;


    if (...) {
      //code logic ensures that date cannot be null.
      //use the ! assertion to let TS know
      const dateStr = date!.toString();
      ...
    }
    ~~~

  + Make use of the .<https://www.typescriptlang.org/play?#code/FDI>
    "TypeScript Playground" for experimenting with TS code.  Understand
    .<https://www.typescriptlang.org/docs/handbook/2/narrowing.html>
    "type narrowing" and make use of 
    .<https://www.typescriptlang.org/docs/handbook/utility-types.html>
    "TypeScript's utility types".

  + If possible, use an editor like VS `code` (available on your VM)
    which is already set up to understand TS.  Mousing over
    an expression will show its type.

    If your editor does not understand TS, then use the following
    workaround to force `tsc` to reveal what it has inferred about
    the type of some expression `expr`:

    .code(lang=ts)
    ~~~
    const x : never = expr
    ~~~

    This will produce an error along the form of ."it is impossible
    to assign `expr` of type `T` to type `never`.", revealing what `T`
    is.

    	      		  Use of ES6 Classes
			  ------------------

At the time of assigning this project, JavaScript objects and ES6
classes will not have been covered in detail in the course.  However,
you should be able to use ES6 .~class~ syntax without needing to
understand the finer points.

Note that the `class` syntax is a relatively recent addition to
JavaScript and is syntactic sugar around JavaScript's more flexible
object model.  Note that even though the use of this `class` syntax
may make students with a background in class-based OOPL's feel more
comfortable, there are some differences worth pointing out:

  + All ."instance variables``." must be referenced through the `this`
    pseudo-variable in both `constructor` and methods.  For example,
    if we want to initialize an instance property `students` in the
    `constructor()` we may use a statement like:

    ~~~
    this.students = {};
    ~~~

    after providing a suitable declaration like `private readonly
    students: Record<T.StudentId, T.Student>` in the `class`.

  + There is no implicit `this`.  If an instance method needs to call
    another instance method of the same object, the method *must* be
    called through `this`.

			Tests
			-----


The provided code contains tests for the project.  Most of them will
fail when you start your project. You will make them succeed, as you
develop your code, thus practising
.<https://en.wikipedia.org/wiki/Test-driven_development> TDD.

You are welcome to add more tests (note that tests different from
those provided here may be used when grading your project).

If you set up your `package.json` as instructed, typing `npm test`
should run all tests using the builtin `node:test` testing framework.

You can run only a single test by replacing the call to the `tst.test(...)`
function defining the test with `tst.test.only(...)`.  You can run only a
single test suite by replacing the call to the `tst.suite(...)`
function defining the suite with `tst.suite.only(...)`.  To skip
a test or suite, use `.skip()` instead of `.only()`.


	   		.=result= Error Reporting
			-------------------------

All methods which may produce errors must return a
.<../../lib/js-utils/src/lib/errors.ts?lang=ts> Result which wraps
either a success result or an error.  The details of
using this wrapper were covered in class in the
.<../../slides/practical-considerations/practical-considerations.html#:~:text=Result%20Type>
"Practical Considerations" slides.


  + Usually, you can import
    all the exported functionality under a namespace like `E`:

    .code(lang=ts)
    ~~~
    import { Errors as E  } from 'cs444-js-utils';
    ~~~


  + To unwrap a `result: E.Result<OkType, ErrType>` use code like the
    following:

    .code(lang=ts)
    ~~~
    if (result.isOk) {
      value: OkType = result.val;
      //process value
    }
    else {
      error: ErrType = result.err;
      //handle error
    }
    ~~~

  + Usually if the result is not okay, then it suffices to return that
    error result to the caller:

    ~~~
    if (!result.isOk) return result;
    ~~~

    Directly returning an error result can sometimes cause problems
    when the `result`'s success type is different from the function's
    success type as in:

    ~~~
    function someFn(...) : E.Result<number, E.Errs> {

      const result: E.Result<string, E.Errs> = someOtherFn();
      if (!result.isOk) return result;
      ...
    }
    ~~~
    
    The compiler will get upset because of the type mismatch.  This
    can be fixed simply by using the `.into<T>()` method available on
    a failed result:

    ~~~
      if (!result.isOk) return result.into<number>();
    ~~~

  + A simple way to generate a successful result `value` is to use the
   `okResult()` factory function:

   ~~~
   return E.okResult(value);
   ~~~

   A simple way to return an error result would be to use the
   `errResult()` factory function:

   ~~~
   if (some validation failure) {
     const msg = `some error message ...`;
     return E.errResult(E.errs(msg, SOME_ERROR_CODE));
   }
   ~~~

     	            IDs
		    ---

.=ids= IDs identifying entities should have the following
requirements:

  + IDs need to be guaranteed to be unique.  This makes an ID based on
    a random number unsuitable, but one based on an incrementing
    counter would work.

  + In order to avoid security issues, ID's should be difficult to
    guess.  This makes an ID based on a random number suitable, but
    one based on an incrementing counter unsuitable.

  + They should not be based on an ID generated automatically by a
    database as that exposes database internals to the outside world.
    In particularly, the id's need to exist independently of a
    database instance and should survive data migrations between
    database instances or to different database systems.

  + IDs should be short to facilitate manual testing during
    development, but it should be easy to make them longer once
    development is complete.

Based on these requirements, a good ID can be a string containing the
following components:

  # A component derived from an incrementing counter.

  # A delimiter character.  Due to mongo limitations, it cannot
    be a period `.`, we use an underscore `_`.

  # A component derived from a random number.  Depending on the
    security requirements of the application, the cryptographical
    properties of the underlying random number generator may become
    important.

Note that the value generated by the counter in (1) must be guaranteed
to be unique across multiple restarts of the application.  To
guarantee that is the case, the counter must be stored in persistent
storage like a database.

Alternately, you can use a random UUID generated using
.<https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID>
crypto.randomUUID() with the downside being that it will be difficult to
type during development and may not be efficient because of its
non-sequential nature.  There are variations like
.<https://github.com/ulid/spec> ULID which avoids the efficiency
problem.

			.=debug= Debugging
			------------------

Look into debugging methods for your project.  Possibilities
include:

  + Logging debugging information onto the terminal using
    .<https://developer.mozilla.org/en-US/docs/Web/API/Console/log>
    console.log(),
    .<https://developer.mozilla.org/en-US/docs/Web/API/Console/error>
    console.error() or
    .<https://developer.mozilla.org/en-US/docs/Web/API/Console/dir>
    console.dir().

    Note that there is a default limit on the maximum depth printed
    for deeply nested objects.  You can get around this by
    stringifying your object `obj` using `JSON.stringify(obj, null,
    2)` or by using `console.dir(obj, { depth: null })`.
	

  + Use the chrome debugger as outlined in this
    .<https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27>
    article.  Specifically, use the `--inspect-brk` node option when
    starting your program and then visit `chrome://inspect` in your
    chrome browser.

	If you have trouble getting to the function you want to
	test, add a line containing the word `debugger` at the point
	at which you would like to get debug control.

    It is well worth spending a few minutes setting up the chrome
    debugger as it could save you a lot of debugging time.


    	  	  	 MongoDB
			 =======

.<https://www.mongodb.com/developer> MongoDB is a popular nosql
database.  This sections gives an overview, not all of which may be
relevant to this project.

With relational databases, the data stored in a row of a table has to
have essentially the same structure as the data stored in another row
of the same table.  That is not the case with a mongodb *collection*
which can store documents which may have different structures (though
it is probably not a great idea to store documents with totally
different different structures within a single collection).

  + In terms of JavaScript, mongodb *documents* correspond to
    arbitrarily nested JavaScript `Object`s having a top-level `_id`
    property which is used as a primary key. If an object does not
    have an `_id` property, then one will be created with a unique
    .<https://mongodb.github.io/node-mongodb-native/6.19/classes/BSON.ObjectId.html>
    ObjectId assigned by mongodb. If a document has a natural ID and
    the timestamping and location independence of `ObjectId` are not
    required, then the `_id` should be set to the natural ID to avoid
    needing an additional index (it will be necessary to let
    TypeScript know the type of `_id` within the `T` type parameter of
    `collection<T>`).

   Note that the `_id` property is an implementation detail and should
   not be exposed externally as it may change in case of database
   migrations.


  + MongoDB provides a basic repertoire of
    .<https://docs.mongodb.com/manual/crud/> "CRUD Operations".

  + All asynchronous mongo library functions can be called directly using
    `await`.

  + It is important to ensure that all database connections are closed.
    Otherwise your program will not exit gracefully.

  + You can play with mongo by starting up a
    .<https://docs.mongodb.com/mongodb-shell/> "mongo shell":


    .code(lang=sh)
    ```
    $ mongosh
    Current Mongosh Log ID:	...
    ...
    For mongosh info see: https://docs.mongodb.com/mongodb-shell/
    ...
    > help

    Shell Help:

    use DB_NAME                    #Set current database
    ...
    ...
    >
    ```


  + *Important*: Since mongodb is available for different languages
    and versions, when looking at documentation make sure that you are
    looking at the
    .<https://www.mongodb.com/docs/drivers/node/current/quick-start/>
    "nodejs documentation" and
    .<https://mongodb.github.io/node-mongodb-native> API for
    v6.x.  This is *very important* as the top results from web
    searches will often point you to inapplicable documentation.

  + It is important to emphasize that mongo is promise-ready.  Hence
    if a mongo function is documented as requiring a callback, then it
    will return a `Promise` when called without a callback; this can
    then be used with `await`.

  + Try to use mongo's facilities as much as possible; for example,
    use mongo's `_id` field to hold ID's; instead of writing code for
    filtering, design your database objects such that you can use the
    filtering capabilities of mongo's
    .<https://mongodb.github.io/node-mongodb-native/6.19/classes/Collection.html#find>
    find() method.  For example, you can use the cursor modification
    methods like
    .<https://mongodb.github.io/node-mongodb-native/6.19/classes/FindCursor.html#sort>
    sort(),
    .<https://mongodb.github.io/node-mongodb-native/6.19/classes/FindCursor.html#skip>
    skip() and
    .<https://mongodb.github.io/node-mongodb-native/6.19/classes/FindCursor.html#limit>
    limit() to sort your results and implement paging within results.
  
  + Usually, there is no need to explicitly create a database or collection in
    mongo; both will be created transparently when data is first
    inserted into a collection in the database.  The exception is when
    the newly created database or collection requires non-default attributes.

  %%%
  + Any attempt to drop a non-existing collection will fail with an
    error.  If this is a possibility in your design, then you should
    check whether a collection exists before attempting to drop it.
    Note that it is possible to list out the collections in a database
    by using the synchronous
    .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Db.html#listCollections>
    db.listCollections() method followed by an asynchronous
    .<http://mongodb.github.io/node-mongodb-native/6.19/classes/ListCollectionsCursor.html#toArray>
    toArray() on the resulting cursor.
  %%%

  + Since opening a connection to a database is an expensive
    operation, it is common to open up a connection at the start of a
    program and hang on to it for the duration of the program.  It is
    also important to remember to close the connection before
    termination of the program (this is handled by the main program
    calling your implementation of the `close()` method).  A common
    cause for program non-termination is a leftover database
    connection.    

    [Note that the provided command-line program for this project
    performs only a single command for each program run.  This is not
    typical and will not be the case in future projects.]

  + .=persistent-setup= It is impossible to have an `async`
    constructor.  Hence a dao wrapping a mongo connection must be
    created using an `async make()` factory function.  This factory
    function will need to perform the following:

      # Get a connection to a mongodb server using the mongo client's
        asynchronous
        .<https://www.mongodb.com/docs/drivers/node/current/connect/mongoclient/>
        connect() method.

      # Given the connection to a server, you can get to a specific
        database using the synchronous
        .<http://mongodb.github.io/node-mongodb-native/6.19/classes/MongoClient.html#db>
        db() method.

	Note that this call to `db()` is not necessary if the `dbUrl`
	used for (1) already specified the database name.

      # Given a database, you can get to a specific collection using
        the synchronous
        .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Db.html#collection>
        collection() method; it will automatically create it if it
        does not exist as long as mongo's
        .<http://mongodb.github.io/node-mongodb-native/api-articles/nodekoarticle1.html#:~:text=strict>
        "strict mode" is off.

	Note that when using TypeScript, it is possible parameterize a
	connection as `collection<T>` to let TypeScript know that the
	type of documents stored in the collection will be `T`.

      # Mongo db .<https://docs.mongodb.com/manual/indexes/> indexes
        can be used to facilitate search.  Given a collection, create
        any necessary indexes using
        .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Collection.html#createIndex>
        createIndex().

        [While indexes do result in better query performance, indexes
         need to be updated during data changes resulting in less
         efficient updates.]

         .=text-index= Mongo db supports a *single*
        .<https://docs.mongodb.com/manual/text-search/> "text index"
        on each collection.  Note that the text index associated with
        a collection can index multiple properties of each document.


      # Call the private constructor passing in all information which
        will be needed by the DAO instance.  Typically, these will
	include the connection and all the collections.

  + Given a collection, a large number of
    .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Collection.html>
    "collection methods" are available:


      + .=insertOne= You can asynchronously insert a single document
        into a collection using the
        .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Collection.html#insertOne>
        "insertOne()" method.  Note that mongo will fail to insert a
        document having the same unique key as that of a document
        already in the collection with an error having `code` set to
        `11000`.

      + .=find= You can synchronously
        .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Collection.html#find>
        find() a cursor to a collection which meets the criteria
        specified by a filter to `find()`.  The query can be used to
        filter the collection; specifically, if the filter specifies a
        primary key like `_id`, then the cursor returned by the
        `find()` should contain at most one result.


          + Given a cursor, you can modify it using the synchronous
            .<http://mongodb.github.io/node-mongodb-native/6.19/classes/FindCursor.html#sort>
            sort(),
            .<http://mongodb.github.io/node-mongodb-native/6.19/classes/FindCursor.html#skip>
            skip() and
            .<http://mongodb.github.io/node-mongodb-native/6.19/classes/FindCursor.html#limit>
            limit() methods.

          + .=toArray= Given a cursor, you can get all its results as
      	    an array using the asynchronous
      	    .<http://mongodb.github.io/node-mongodb-native/6.19/classes/FindCursor.html#toArray>
      	    toArray() method.

 

      + .=findOneAndUpdate= You can asynchronously update a document
        in a collection using the
        .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Collection.html#updateOne>
        updateOne() or
        .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Collection.html#findOneAndUpdate>
        findOneAndUpdate() method.  Note that the
        .<https://docs.mongodb.com/manual/reference/method/db.collection.update/#std-label-update-upsert>
        upsert option is useful if you wish to create a new document
        when there is no existing document to be updated.  Note also
        that the latter can return the document after the update if
        the
        .<http://mongodb.github.io/node-mongodb-native/6.19/interfaces/FindOneAndUpdateOptions.html#returnDocument>
        returnDocument option is set to `mongo.ReturnDocument.AFTER`.


      + .=deleteOne= You can asynchronously delete a single document
        from a collection using
        .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Collection.html#deleteOne>
        deleteOne() or many documents from it using
        .<https://mongodb.github.io/node-mongodb-native/6.19/classes/Collection.html#deleteMany>
        deleteMany().


      + Given a collection, you can asynchronously replace a document
        using the
        .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Collection.html#replaceOne>
        replaceOne() or
        .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Collection.html#findOneAndReplace>
        findOneAndReplace() method.  Note that the
        .<https://docs.mongodb.com/manual/reference/method/db.collection.update/#std-label-update-upsert>
        upsert option is useful if you wish to create a new document
        when there is no existing document to be replaced.


 + .=partial-updates= Mongo db supports partial updates within a *single
   document*.  Here are some examples in the mongo shell:

   .code(lang=js)
   ~~~
   $ mongosh
   Current Mongosh Log ID:	...
   Connecting to:		mongodb://127.0.0.1:27017/?direct...

   ...
   // insert document with _id 99 into db in tests collection
   // in default test db
   test> db.tests.updateOne({_id: 99},  //query
                            { $set: { life: { meaning: 42 } }}, //update op
			    { upsert: true }) //insert if not present
   ...

   // list all documents in tests collection
   test> db.tests.find()
   [ { _id: 99, life: { meaning: 42 } } ]

   // update portion of document
   test> db.tests.updateOne( { id: 99 },
                             //note use of . to access nested doc
                             { $set: { 'life.meaning': null } },
			     { upsert: true})

   // show updated document			     
   test> db.tests.find()
   [ { _id: 99, life: { meaning: null } } ] //null is fine

   test> db.tests.updateOne({ _id: 99 },
                            { $set: { 'end.of.life': 99 } }, //auto-vivification
			    { upsert: true})
   ...			    
   test> db.tests.find()
   [
    { _id: 99, life: { meaning: null }, end: { of: { life: 99 } } }
   ]
   test> //type ^D to exit
   $
   ~~~

  + Unlike relational databases, Mongo does not provide foreign key
    constraints, but it does support .<https://www.mongodb.com/docs/manual/tutorial/unique-constraints-on-arbitrary-fields/> "unique key constraints".  It
    also supports .<https://www.mongodb.com/docs/manual/core/transactions/>
    transactions.

%%%
    Note that mongo supports
    .<https://docs.mongodb.com/manual/geospatial-queries/>
    "geo-spatial indexes"%

    Ideally, indexes should be created on a collection before the
    collection itself is created.  Hence when getting the initial
    connection to a database it is a good idea to check whether a
    collection exists and create the collection and its indexes when
    it does not.  Note that the check can be done using the
    aforementioned
    .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Db.html#listCollections>
    db.listCollections() method.


        .=ops= If the value of the filter field is an object
        containing properties for one of mongodb's
        .<https://docs.mongodb.com/manual/reference/operator/query/>
        "query selectors", then the filter can do more than merely
        match the find parameters.

        Specifically, the `$gte` and `$lte`
	selectors can be used to match values which are `>=` or `<=` the
    	specified value.

      + .=findOne= Given a collection, you can asynchronously find a
        single document using the
        .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Collection.html#findOne>
        "findOne()" method.



  + By default, queries are case-sensitive.  If case-insensitive
    queries are to be performed, then a `collation` option like `{
    locale: 'en', strength: 2 }` must be specified.  This can be
    specified for each individual query and index but it can also be
    set up when creating the collection using the
    .<http://mongodb.github.io/node-mongodb-native/6.19/classes/Db.html#createCollection>
    db.createCollection() method:

      ~~~
      createCollection(COLLECTION_NAME,
                       { collation: { locale: 'en', strength: 2 }})
      ~~~

     OTOH, note that `text` indexes are case-insensitive by default.


%%%

%%%
			.=ds= JS Objects as Maps
			------------------------

JavaScript objects work like maps or Python dictionaries.
Specifically, an object with TS `type Dict<T> = { [key: string]: T }`
or `type Dict<T> = Record<string, T>` serves as a dictionary mapping
`string` keys to objects of type `T`.  This can form the basis for
indexing data within your `Grades` class:


  + Note that the .<prj1-sol/src/lib/types.ts?lang=ts#:~:text=RowData>
    "provided types" define:

    .code(lang=ts)
    ~~~
    type RowData = Record<ColId, Entry>;
    type SectionData = Record<RowId, DataRow>;
    ~~~

  + You can use a `Record<SectionId, Section>` to map section-ids
    into all info and data for a section.


This basic data structure will get you far into the project.

%%%

	        	    .=design= Design Ideas
			    ======================

At first glance, it appears that the `User`, `ChatRoom` and `ChatMsg`
entities can be mapped directly into mongo collections.  However, the
`updateUser()` method you are required to implement introduces
complications (also, though you are not required to implement an
update for `ChatRoom`s, the type implies that this is a distinct
policy.)

Hence if the database entity for a `ChatMsg` directly stored the
`chatName` and `roomName` fields, any update to these fields via
the `User` or `ChatRoom` entities would be extremely clumsy, requiring
an update of an unlimited number of `ChatMsg`s.

A better solution would be to replace the `chatName` and `roomName`
fields with `userId` and `roomId` fields.  Now any change to the
values of `chatName` or `roomName` would not require any updates
at all to chat-messages.  The cost is somewhat more complex code for
chat-message operations:

  + Creating a chat-message would require having `makeChatMsg()`
    translating `chatName` and `roomName` values to `userId` and
    `roomId` values.

  + Finding chat-messages would require having `findChatMsgs()`
    translating `chatName` and `roomName` search fields (if any)
    to the corresponding IDs.

In terms of relational databases, chat-message operations require
join operations.  Since mongo does not directly support joins,
the joins will need to be done manually, possibly within a
transaction.

Based on the above observations:

  # Decide on the names of the collections for your mongo db.

  # For each collection decide on the type of the document
    stored in that collection.  Those types will largely be the
    same as those of the chat entities with the important
    caveats mentioned above (another difference would be to
    use mongo's `_id` field rather than the `id` fields in
    the entity types).

  # Decide on indexes for your collections.  Use the indexes
    to facilitate efficient search and ensure that uniqueness
    constraints are satisfied.

			Hints
			=====

The following points are worth noting:

  + The methods you are required to implement must return a
    .<../../lib/js-utils/src/lib/errors.ts?lang=ts> Result which wraps
    either the success result or any encountered errors.  The details
    of using this wrapper were covered in class in the
    .<../../slides/practical-considerations/practical-considerations.html#:~:text=Result%20Type>
    "Practical Considerations" slides.

  + Since you have already been provided with tests, you will be
    practising .<https://en.wikipedia.org/wiki/Test-driven_development>
    "Test-Driven Development" (TDD).

       + If you would like to run only a particular test suite, change
         the `tst.suite(...)` for that test suite to `tst.suite.only(...)`.

       + If you would like to run only a particular test, change
         the `tst.test(...)` for that test to `tst.test.only(...)`.

       + If you would like to skip a test or suite, use `skip`
         instead of `only`.


  + You should feel free to use any of the functions from the standard
    .<https://developer.mozilla.org/en-US/docs/Web/JavaScript>
    library; in particular, functions provided by the
    .<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array>
    Array,
    .<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/>
    String,
    .<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set>
    Set and
    .<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math>
    Math objects may prove useful.  Note also that the JavaScript's
    .<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set>
    Set API provides 
    .<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/add>
    add() and
    .<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has>
    has() methods, including recently added 
    .<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/union> union and
    .<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/intersection>
    intersection methods.

  + The two files you will be changing in this project are
    .<./prj1-sol/src/lib/chat.ts?lang=ts> chat.ts and
    .<./prj1-sol/src/lib/chat-dao.ts?lang=ts> chat-dao.ts.  The former
    will be a rather thin wrapper over the latter.  The DAO should
    contain all db-specific code whereas the wrapper provides a layer
    over it which can be used to implement database-independent domain
    logic.  For example, the next project will use the wrapper to add
    additional validations (for `E_BAD_VAL` errors).

    The provided .<prj1-sol/src/lib/chat-dao.ts?lang=ts> "DAO
    skeleton file" does not contain any methods for the DAO.  This
    provides you more of a blank slate on which you can design your
    own DAO API.



The following steps are not prescriptive in that you may choose to
ignore them as long as you meet all project requirements.

  # Understand the .<#require> "project requirements".  Make sure you
    understand the types in
    .<./prj1-sol/src/lib/chat-types.ts?lang=ts> chat-types.ts.

  # Review the .<#design> "Design Ideas" to make sure you understand
    how you will approach the project.

  # Follow the provided .<../working/working.html#start> "generic instructions"
    to start work on your project.  You should have set up a project
    directory with a `package.json`, `README` filled in, with everything commited to your `i?44` repository on github,

  # Capture an image to validate that you have set up your course VM
    as instructed.  Within a terminal window in your `x2go` client
    window, type in the following commands:

    .code(lang=sh)
    ```
    $ hostname; hostname -I
    $ ls ~/cs544
    $ ls ~/i?44
    $ crontab -l | tail -3
    ```

    Use an image capture program on your *workstation* to capture an
    image of your `x2go` client window into a file `vm.png`.  The
    captured image should show the terminal window containing the
    output of the above commands as part of the `x2go` client window.
    Move the `vm.png` file from your workstation to your VM's
    `~/i444/submit/prj1-sol` directory (you can use `scp`; if your
    workstation cannot connect directly to your VM, then do a two step
    copy using `remote.cs` as an intermediate).

    Add, commit and push the `vm.png` file.


  # Replace the `scripts` section of your generated `package.json`
    with the following lines:

    ~~~
    "clean": "shx rm -rf dist",
    "dist-clean": "shx rm -rf dist node_modules package-lock.json",
    "build": "npx tsc",
    "postbuild": "shx test -e dist/index.js && shx chmod a+x dist/index.js || true",
    "watch": "tsc --watch",
    "pretest": "npm run build",
    "test": "node dist/test/tst-*.js",
    "predebug-test": "npm run build",
    "debug-test": "node --inspect-brk dist/test/tst-*.js"
    ~~~

    Since `package.json` uses strict JSON syntax, be careful to
    avoid trailing commas.

      : `clean` :
        Removes the `dist` directory which is specified as the `tsc`
	output directory by the provided .<prj1-sol/tsconfig.json?lang=json>
	tsconfig.json.

      : `dist-clean` :
         Clean out everything, including all downloaded libraries.

      : `build` :
        Run the `tsc` compiler using options specified by
	.<prj1-sol/tsconfig.json?lang=json> tsconfig.json.
	The distributed `tsconfig.json` is set up to compile
	`*.ts` files from your `src` directory to the `dist`
	directory.

      : `watch` :
        Rerun the `tsc` compiler when any of the source files
	change.  You can keep this command running in a terminal
	and any file changes will automatically trigger a recompile.

      : `test` :
        Run all generated tests in the `dist/test` directory.  The
        `pretest` script will automatically be run before `test`,
        ensuring that the build is always up-to-date before testing.

      : `debug-test` :
        Like `test`, but pause until connected to by the
	chrome debugger.

    You can run any of the above scripts using `npm run` "script",
    where "script" is name of the script.  You can run tests
    directly as simply `npm test`.

  # Add the declaration `"type": "module",` after the `scripts`
    section in `package.json`.  This will ensure that node
    treats `*.mjs` files as ES6 JavaScript modules.

  # Use `npm install -D` to install the following packages as
  *development* dependencies: `@types/node`, `@types/semver`, `chai`,
  `shx`, `mockdate`, `mongodb-memory-server` and `typescript`.

      + The `@types/*` packages provide the typescript compiler with
        information about the types exported by the respective
        JavaScript projects.

      + The `chai` package is an assertion library providing somewhat
        more friendly assertion syntax than that available in node.

      + `shx` allows portable execution of some selected user commands;
      	note that this will allow the commands to also be used on Windows.

      + `mockdate` and `mongodb-memory-server` are used during testing
        to mock dates and mongodb respectively.

      + Installing `typescript` ensures your project uses a project-specific
        typescript installation (rather than the one installed system wide
	on your VM).

    The `-D` option marks the dependencies as those needed only during
    project development and not needed when running your project.

  # Install the following runtime dependencies using the `npm install`
    command (without any `-D` option):

    ```
    mongodb
    https://sunybing:sunybing@zdu.binghamton.edu/cs444/lib/cs444-js-utils-0.0.1.tgz
    https://sunybing:sunybing@zdu.binghamton.edu/cs444/lib/cs444-node-utils-0.0.1.tgz
    ```

    The latter two dependencies are built from the source code contained
    in the .<../../lib> lib course library directory.

  # Build your project using `npm run build`.  It should build without
    errors if everything was set up correctly.

    Spend a few minutes poking around in the generated `prj1-sol/dist`
    directory and notice that the generated JS files are very similar
    to the source TS files.  Being familiar with this directory may
    prove useful to track down runtime errors which are reported using
    line numbers in the JS files.

  # Run the provided tests using `npm test`. Most of the tests will
    fail.  Deactivate all the tests by changing the top level
    `tst.suite(` in `src/test/tst-chat.ts` to `tst.test.skip(`.  Rerun
    the tests and verify that no tests are being run.

    Also, run the provided command-line program.  It should run well
    enough to provide a usage message:

    .code(lang=sh)
    ~~~
    $ ./dist/index.js 
    index.js DB_URL CMD ...
    for CMD in
     make-user chat-name=CHAT_NAME email=EMAIL first-name=FIRST_NAME 
                last-name=LAST_NAME 
                Make a new user and print its newly created ID. 
      get-user user-key=USER_KEY 
                Output all info for chat-user specified by USER_KEY, 
    ...
          help 
                Print this message 
    ~~~

  # Write types for your collection types in your `chat-dao.ts` file.
    Try to derive them from the `T.*` types using typescript's
    .<https://www.typescriptlang.org/docs/handbook/utility-types.html>
    "utility types".  The skeleton file provides a couple of examples
    to help you get started.  The db type for chat messages will need
    to replace the `chatName` and `roomName` with the equivalent
    ID fields.

    Since the brands on branded types are purely compile-time
    artifacts, you can freely use branded types within your database
    types.  This will make typescript automatically coerce raw types
    stored in the database to branded types when retrieved.
    

  # Work on the `make()` factory method within the dao class.  Start
    up by .<#persistent-setup> "opening a connection" to the specified
    mongo URL.  Then create all the necessary collections and indexes.
    When creating a collection `name` for documents having type `T`,
    be sure to parameterize the creation call with the type as in
    `db.collection<T>(name)` where `T` is a type you constructed in
    the previous step.

    Like all your top-level DAO methods, this method should be
    structured as follows:

    .code(lang=ts)
    ~~~
    try {
      // ... stuff including early error returns
      return E.okResult(some-success-result);
    }
    catch (error) {
      //convert what should be a mongo exception to a Result
      return E.errResult(E.errs((error as Error).message, 'E_DB'));
    }
    ~~~

    Using the command-line program to run the program at this stage
    should hang.  This is because the program attempts to terminate
    while leaving a db connection open.

  # Add code to `close()` the DAO and hook up the `close()` method in
    `chat.ts` to call it.  Now when you run the command-line program,
    it should terminate cleanly.

  # Implement a `clear()` method on your  DAO and hook it up to the
    one in `chat.ts`.  You can simply using         .<https://mongodb.github.io/node-mongodb-native/6.19/classes/Collection.html#deleteMany>
        deleteMany({}) on all the collections in your design.

    Do not forget to include the top-level `try-catch` to convert
    any mongo exceptions into `Result`s.

  # Now implement a DAO method which can be called by `Chat::makeUser()`.
    First, you will need to build a db type out of the incoming
    `T.RawUser`.

      # Use your chosen id-generation method to create a new
        `T.UserIdX` ID.

      # Set up a timestamp to be stored for the creation and
        last-update times:

        ~~~
	const now = T.brand<T.Iso8601X>(new Date().toISOString());
	~~~

      # Use the .<#insertOne> insertOne() method to insert the db
        data.

      # If you have correctly set up unique indexes on your
        collection, mongo should trigger an exception on any
	attempt to insert user data having the same `email`
	or `chatName` as that of a previously created
	user.  Use a test within your `try { ... }` block
	to distinguish this error from other errors:

        .code(lang=ts)
	~~~
    	catch (e) {
      	  if ((e instanceof mongo.MongoError) &&
	      (e.code ?? 0) === MONGO_UNIQUE_ERR) {
	    return E.errResult(E.errs(`...`, 'E_EXISTS'));
          }
      	  else {
	    return E.errResult(E.errs((e as Error).message,
	                      'E_DB'));
        }
	~~~

  # Implement a DAO method to implement the `getUser()` functionality.
    You may need some initial manipulation to move the `id` parameter
    into the `_id` if you are storing `id` fields using mongo's `_id`.
    Then simply call mongo's .<#findOne> findOne().  If the value
    returned by `findOne()` is falsy, return a suitable `E_NOT_FOUND`
    error.  Before returning the value read from the database, it may
    need some cleanup to convert `_id` to `id`.

  # Enable the `users` test suite in `src/test/tst-chat.ts`.
    Specifically, remove the `.skip` from the top-level `Chat`
    suite and add it to all next-level suites except for the `users`
    suite.

    Run tests using `npm test`, making any necessary code changes to
    make all the tests pass.

  # Implement functionality within the DAO to support the
    `makeChatRoom()` and `getChatRoom()` methods.  These will be
    very similar to the `makeUser()` and `getUser()` methods.

    Enable the `chat rooms` suite and update your code until
    all tests pass.  Three of the tests have been marked
    as `.todo()`.  Implement those tests by understanding similar
    tests and copy-and-pasting in code with suitable modifications.

  # Add functionality to the DAO to support the `updateUser()`
    method.  You can base your code around the functionality
    provided by mongo's .<#findOneAndUpdate> findOneAndUpdate()
    which should be invoked on the corresponding collection as

    .code(lang=ts)
    ~~~
    ... .findOneAndUpdate(query, {$set: updates}, options);
    ~~~

    where:

      + `query` should select the document to be updated
        based on the provided `id` (possibly reflected into
	mongo's `_id`).

      + `updates` are the requested updates enhanced with
        a `lastUpdateTime` set to now.

      + `options` should be set to `{ returnDocument:
        mongo.ReturnDocument.AFTER }` to facilitate the required return
        value.

    As for `makeUser()` the database value may need some cleanup before
    being returned.

    Validate your code by turning on the corresponding test suite.

  # Now implement the DAO functionality for the `makeChatMsg()`
    method.

    As mentioned in the earlier .<#design> discussion, that while the
    external `T.ChatMsg` has `chatName` and `roomName` fields, it is
    undesirable that those fields be stored within the db chat-message
    to facilitate changing those fields.  Hence the `makeChatMsg()`
    functionality can be implemented in the DAO as follows:

      # Use the previously functionality previously implemented in the
        DAO to support the `getUser()` method to convert the
        `chatName` into a `userId`.  

      # Similarly, use the `getChatRoom()` functionality to convert a
        `roomName` to a `roomId`.

      # Add a private method to the DAO which takes a chat message
        having the db chat-message type (the one where the `chatName`
	and `roomName` fields have been replaced by the corresponding
	`ID`s).  This should be a fairly simple wrapper around mongo's
	`insertOne()` similar to the previously implemented `addUser()`
	and `addChatRoom()` methods.

      # Add a method to the DAO which directly supports the external
        `makeChatMsg()` functionality.  This will merely call the
	modified `getUser()` and `getChatRoom()` functionality to
	convert the names to IDs and then call the above private
	method.  You will need to ensure an early error return if
	any of the calls fail.

  # Implement the DAO functionality for the `findChatMsgs()` method.
    The `roomName` and the optional `chatName` in findParams will need
    to be converted to ID's.  This will be very similar to what you
    did for `makeChatMsg()` except that it is complicated slightly by
    the fact that the `chatName` parameter is optional.

    As for `makeChatMsg()`, the guts of the find can then be delegated
    to a private method.

    The reverse conversion will need to be done on the db value
    returned by the private method (containing IDs) to the external
    `ChatMsg` type containing names.  This can again be implemented
    doing a lookup by ID using `getUser()` and `getChatRoom()`.

    The private method should be set up to use the functionality of
    mongo's .<#find> find() to implement the search.  The code is
    complicated by the fact that the parameters to mongo's `find()`
    need to be built up from optional parameters.

    To start with, use destructuring to take apart the the incoming
    `search` field having a type similar to `T.FindParams` (the difference
    is that the `chatName` and `roomName` fields will have been replaced
    by the corresponding ID's):

    .code(lang=ts)
    ~~~
    const { offset = 0, limit = T.PAGE_SIZE, id, words, earliest, latest,
           ...query1 } = search;
    ~~~

    The above destructures search into the fields which need special
    handling with other fields grabbed in `query1`.

    Depending on the presence of the optional search fields, create
    a new query from `query1` (a field is present if its value
    is not `undefined`):

       + If `words` is present, add in a `$text` property with
         value `{ $search: words }`.  This assumes that you
	 have created a .<#text-index> "text index" on the collection.

       + If `earliest`/`latest` are present add in a `creationTime`
         property having properties `{ $gte: earliest, $lte: latest }`
         (only one property should be present if only one of
         `earliest`/`latest` is present.

    The modified `query` can then be used to asynchronously invoke
    `.find()` on the appropriate collection.  The returned cursor
    should be processed to meet the project requirements:

    .code(lang=ts)
    ~~~
    .sort({ creationTime: -1, msg: 1, _id: 1 })
    .skip(offset)
    .limit(limit);
     ~~~

    The `sort()` sorts the cursor by non-ascending order of
    `creationTime` then by non-descending order by `msg` and then by
    ascending order of the internal `_id`.

    The processed cursor results can then be collected into an array
    using the asynchronous .<#toArray> toArray() method.  The db
    values in the array may require `_id` to `id` cleanup.

  # Turn on all test suites including the `Chat Messages` and
    `user updates must be reflected ...` suites.

  # Iterate until all tests pass.

  # Clean up your code.  Activate all tests.  Remove any debugging
    code like print statements.

  # Update your `README` with any information you need the grader to
    read.  Do this only if you have not met or exceeded the project
    requirements.  Do not include information already provided in the
    assignment.
    
  # Complete and submit your project as per the
    .<../working/working.html#complete> "generic working directions".